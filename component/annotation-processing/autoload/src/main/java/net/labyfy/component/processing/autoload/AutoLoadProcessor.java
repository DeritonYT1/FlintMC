package net.labyfy.component.processing.autoload;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import net.labyfy.component.commons.consumer.TriConsumer;
import net.labyfy.component.processing.Processor;
import net.labyfy.component.commons.annotation.AnnotationMirrorUtil;
import net.labyfy.component.processing.ProcessorState;

import javax.lang.model.element.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

/**
 * The class generating classes for elements annotated with @AutoLoad or annotations
 * marked as @AutoLoad. The corresponding META-INF/services file is generated by the
 * {@link AutoService} annotation on this class.
 */
@AutoService(Processor.class)
public class AutoLoadProcessor implements Processor {

  private final Map<Integer, Map<String, Integer>> autoLoadClasses;

  /**
   * Constructs a new {@link AutoLoadProcessor}, expected to be called by a {@link java.util.ServiceLoader}
   */
  public AutoLoadProcessor() {
    this.autoLoadClasses = new HashMap<>();
  }

  /**
   * {@inheritDoc}
   */
  public MethodSpec.Builder createMethod() {
    ClassName triConsumerClass = ClassName.get(TriConsumer.class);
    ClassName integerClass = ClassName.get(Integer.class);
    ClassName stringClass = ClassName.get(String.class);

    // Create a method with the signature
    // `void registerAutoLoad(net.labyfy.base.structure.util.TriConsumer<Integer, Integer, String>)`
    return MethodSpec.methodBuilder("registerAutoLoad")
        .addAnnotation(Override.class)
        .addModifiers(Modifier.PUBLIC)
        .addParameter(
            ParameterizedTypeName.get(triConsumerClass, integerClass, integerClass, stringClass),
            "autoLoadClasses")
        .returns(void.class);
  }

  /**
   * {@inheritDoc}
   */
  public ClassName getGeneratedClassSuperClass() {
    return ClassName.get(AutoLoadProvider.class);
  }

  /**
   * {@inheritDoc}
   */
  public void accept(TypeElement typeElement) {
    // Determine if the annotation defined by `typeElement` is also marked with @AutoLoad
    if (AnnotationMirrorUtil.collectTransitiveAnnotations(typeElement).stream()
            .noneMatch(
                annotationMirror ->
                    ((TypeElement) annotationMirror.getAnnotationType().asElement())
                        .getQualifiedName()
                        .toString()
                        .equals(AutoLoad.class.getName()))
        && !typeElement.getQualifiedName().toString().equals(AutoLoad.class.getName())) return;

    // Find all elements annotated with this annotation and process them
    ProcessorState.getInstance().getCurrentRoundEnvironment().getElementsAnnotatedWith(typeElement)
        .stream()
        .map(
            (element) -> {
              // Only classes can be marked as auto load, so skip
              if (!(element instanceof TypeElement)) return null;
              return (TypeElement) element;
            })
        .filter(Objects::nonNull)
        .filter(
            (element) ->
                // Make sure we don't process annotation classes
                element.getKind() == ElementKind.CLASS
                    || element.getKind() == ElementKind.INTERFACE)
        .filter(
            (element) -> {
              // Filter outer anonymous classes
              String name = element.getQualifiedName().toString();
              return name != null && !name.isEmpty();
            })
        .forEach(
            element -> {
              // Calculate the priority with a default value of 0
              Integer priority =
                  (Integer)
                      AnnotationMirrorUtil.getAnnotationValue(
                              AnnotationMirrorUtil.getTransitiveAnnotationMirror(
                                  element, AutoLoad.class.getName()),
                              "priority",
                              new AnnotationValue() {
                                public Integer getValue() {
                                  return 0;
                                }

                                public <R, P> R accept(
                                    AnnotationValueVisitor<R, P> visitor, P parameter) {
                                  return visitor.visitInt(getValue(), parameter);
                                }
                              })
                          .getValue();

              // Calculate the round with a default value of 1
              Integer round =
                  (Integer)
                      AnnotationMirrorUtil.getAnnotationValue(
                              AnnotationMirrorUtil.getTransitiveAnnotationMirror(
                                  element, AutoLoad.class.getName()),
                              "round",
                              new AnnotationValue() {
                                public Integer getValue() {
                                  return 1;
                                }

                                public <R, P> R accept(
                                    AnnotationValueVisitor<R, P> visitor, P parameter) {
                                  return visitor.visitInt(getValue(), parameter);
                                }
                              })
                          .getValue();

              // Make sure to get a name which can be used with reflection
              String name =
                  ProcessorState.getInstance()
                      .getProcessingEnvironment()
                      .getElementUtils()
                      .getBinaryName(element)
                      .toString();

              this.autoLoadClasses.computeIfAbsent(round, (k) -> new ConcurrentHashMap<>()).put(name, priority);
            });
  }

  /**
   * {@inheritDoc}
   */
  public void finish(MethodSpec.Builder targetMethod) {
    // Add a statement for all classes
    autoLoadClasses.forEach(
        (round, map) ->
            map.forEach(
                (name, priority) -> {
                  targetMethod.addStatement(
                      "autoLoadClasses.accept($L, $L, $S)", round, priority, name);
                }));
  }
}
