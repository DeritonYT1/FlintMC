package net.labyfy.component.config.generator.method;

import javassist.CannotCompileException;
import javassist.CtClass;
import javassist.NotFoundException;
import net.labyfy.component.config.annotation.Config;
import net.labyfy.component.config.generator.ConfigGenerator;
import net.labyfy.component.config.generator.GeneratingConfig;
import net.labyfy.component.config.generator.ParsedConfig;
import net.labyfy.component.config.storage.ConfigStorageProvider;

import java.lang.reflect.Type;

/**
 * Represents a method which should be defined in a config that is currently being generated by a {@link
 * ConfigGenerator}.
 */
public interface ConfigMethod {

  /**
   * Retrieves the interface where this method has been discovered, this is not the class which is being implemented.
   *
   * @return The non-null class where this method has been discovered
   */
  CtClass getDeclaringClass();

  /**
   * Retrieves the name as which this method will be stored in the config (only the ending of it). The prefix to the
   * entry in the config is defined with {@link #getPathPrefix()}. This is parsed from the specific type of method in
   * {@link ConfigMethodResolver#resolveMethods(GeneratingConfig)}, so for example 'getX' would be 'X', see {@link
   * Config} for more information on how this is parsed.
   *
   * @return The non-null suffix of the config
   */
  String getConfigName();

  /**
   * Retrieves the name of the getter to get the result which should be serialized in the config. To construct this,
   * {@link #getConfigName()} will be used.
   *
   * @return The non-null name of the getter
   */
  String getGetterName();

  /**
   * Retrieves the name of the setter to set the result which has been be deserialized from the config. To construct
   * this, {@link #getConfigName()} will be used.
   *
   * @return The non-null name of the setter
   */
  String getSetterName();

  /**
   * Retrieves an array of all methods that are associated with this method, this can be for example 'getAllX',
   * 'setAllX', 'getX', 'setX'. It may be used to get all annotations for a specific entry.
   *
   * @return The non-null and non-empty array of method names
   */
  String[] getMethodNames();

  /**
   * Retrieves all types that are associated with this method, this will be every parameter and the return type (if not
   * void) of the methods from {@link #getMethodNames()}.
   *
   * @return The non-null and non-empty array of types that belong to this method
   */
  CtClass[] getTypes();

  /**
   * Retrieves the type that will be stored in the config, so for example for 'int getX()' or 'void setX(int x)' this
   * would be int.
   *
   * @return The non-null type to be serialized
   */
  CtClass getStoredType();

  /**
   * Retrieves the type for serialization of this method. For example if the method is 'int getX()' or 'void setX(int
   * x)', the type would be {@link Integer#TYPE int.class}.
   * <p>
   * If the method consists of multiple values (key-value) and the method looks like this 'int getY(String key)', the
   * type would be {@code Map<String, Integer>}.
   * <p>
   * If the classes are already defined in the {@link GeneratingConfig}, the implementations will be used for the Type.
   *
   * @param config The non-null config which contains this method
   * @return The non-null type for serialization
   */
  Type getSerializedType(GeneratingConfig config);

  /**
   * Retrieves the path prefix to be used in the config.
   *
   * @return The non-null (may be empty) array of prefixes
   */
  String[] getPathPrefix();

  /**
   * Changes the path prefix, this method can only be called once.
   *
   * @param pathPrefix The non-null prefix (may be empty)
   * @throws IllegalStateException If the method has been called twice or more
   */
  void setPathPrefix(String[] pathPrefix) throws IllegalStateException;

  /**
   * Retrieves whether the {@link #getStoredType()} is a {@link java.util.Map} or {@link java.util.Collection} or any
   * sub class.
   * <p>
   * Alias for {@link #isSerializableInterface(CtClass)} with {@link #getStoredType()}.
   *
   * @return Whether the type is a Map or Collection
   * @see #isSerializableInterface(CtClass)
   */
  boolean isSerializableInterface();

  /**
   * Retrieves whether the given type is a {@link java.util.Map} or {@link java.util.Collection} or any sub class.
   *
   * @param type The non-null type to check for
   * @return Whether the type is a Map or Collection
   */
  boolean isSerializableInterface(CtClass type) throws NotFoundException;

  /**
   * Generates all methods that are necessary like the getters and setters and the necessary field for those
   * setters/getters, this depends on the implementation. If any method already exists, these methods won't be
   * generated, but it doesn't affect other methods.
   *
   * @param target The non-null class where the methods and the field should be generated
   * @param config The non-null config with all information about the implementations
   * @throws CannotCompileException If an internal error occurred while generating the code, should basically never
   *                                happen
   */
  void generateMethods(CtClass target, GeneratingConfig config) throws CannotCompileException;

  /**
   * Adds the {@link ConfigStorageProvider#write(ParsedConfig)} call to every setter method.
   *
   * @param target The non-null class where the methods and the field should be generated
   * @param config The non-null config with all information about the implementations
   * @throws CannotCompileException If an internal error occurred while generating the code, should basically never
   *                                happen
   * @throws NotFoundException      If any of the methods in {@link #getMethodNames()} don't exist, they cannot be
   *                                generated because we don't know the implementation
   */
  void implementExistingMethods(CtClass target, GeneratingConfig config) throws CannotCompileException, NotFoundException;

}
