import java.text.SimpleDateFormat

group 'net.flintmc'

buildscript {
    def versionFile = file(".dev-version")
    def fixedVersion = null
    if (versionFile.exists()) {
        fixedVersion = versionFile.text.replace("\n", "")
    } else {
        throw new GradleScriptException("VERSIONFILE COULD NOT BE FOUND!", new Throwable("Please check the CI!"))
    }

    dependencies {
        classpath "org.jfrog.buildinfo:build-info-extractor-gradle:4+"
        classpath "net.labyfy:labyfy-gradle-javadocs-plugin:1.0.0"
        classpath "net.labyfy:labyfy-gradle-plugin:2.0.2"
    }

    repositories {
        maven {
            url = System.getenv().getOrDefault("artifactory_contextUrl", project.getProperties().get("artifactory_contextUrl").toString()) + "general/"
        }
        mavenCentral()
        jcenter()
        mavenLocal()
    }
}

// adds labyfy tasks
apply plugin: 'labyfy-gradle'

// adds docyfy task
apply plugin: 'labyfy-gradle-javadocs-plugin'

labyfy {
    projectFilter { !["annotation-processing", "autoload"].contains(it.name) }
    publishToken 'NzQzMjZkYTljMmU3NzlmMDU2NDQ3NTkz'
    runs {
        overrideMainClass 'net.flintmc.launcher.FlintLauncher'
    }
}

subprojects {
    task allDeps(type: DependencyReportTask) {}
}
repositories {
    mavenCentral()
    mavenLocal()
}

def versionFile = file(".dev-version")
def fixedVersion = null
if (versionFile.exists()) {
    fixedVersion = versionFile.text.replace("\n", "")
} else {
    throw new GradleScriptException("VERSIONFILE COULD NOT BE FOUND!", new Throwable("Please check the CI!"))
}

allprojects {
    version fixedVersion
    buildscript {
        repositories {
            maven {
                url = System.getenv().getOrDefault("artifactory_contextUrl", project.getProperties().get("artifactory_contextUrl").toString()) + "general/"
            }
            mavenCentral()
            jcenter()
            mavenLocal()
        }
    }

    apply plugin: 'maven'
    apply plugin: "com.jfrog.artifactory"
    apply plugin: 'maven-publish'

    configurations.all {
        resolutionStrategy {
            force 'org.apache.logging.log4j:log4j-api:2.8.2'
            force 'com.google.guava:guava:27.0.1-jre'
            force 'org.apache.commons:commons-lang3:3.10'
            force 'org.apache.logging.log4j:log4j-core:2.8.2'
            force 'it.unimi.dsi:fastutil:8.2.1'
            force 'net.java.dev.jna:jna:4.4.0'
            force 'com.google.code.findbugs:jsr305:3.0.2'
            force 'com.google.code.gson:gson:2.8.6'
            force 'commons-io:commons-io:2.6'
            force 'commons-codec:commons-codec:1.10'
            force 'com.beust:jcommander:1.78'
            failOnVersionConflict()
        }
    }

    artifactory {
        contextUrl = System.getenv().getOrDefault('artifactory_contextUrl', "${artifactory_contextUrl}")
        //The base Artifactory URL if not overridden by the publisher/resolver
        publish {
            repository {
                repoKey = 'labymedia'
                username = System.getenv().getOrDefault("artifactory_user", "${artifactory_user}")
                password = System.getenv().getOrDefault("artifactory_password", "${artifactory_password}")
                maven = true

            }
            defaults {
                publications('mavenJava')
            }
        }
        resolve {
            repository {
                repoKey = 'general'
                username = System.getenv().getOrDefault("artifactory_user", "${artifactory_user}")
                password = System.getenv().getOrDefault("artifactory_password", "${artifactory_password}")
                maven = true

            }
        }
    }

    /*
     * NOTE: This is important, else Java will keep files locked which gradle
     *       tries to overwrite. This is an issue with annotation processors
     *       and there is no real way to fix it, other than executing the
     *       annotation processor in an external process.
     *
     * What exactly is happening?
     * Gradle loads our general annotation processing module (and its annotation processor), which in return
     * loads other annotation processors using the service loader. With the fork option disabled
     * (default setting in gradle) the jar file the autoload processor is in is kept loaded in the gradle daemon, thus
     * locking the file on disk. Subsequent executions of builds may try to write to this file and then fail
     * catastrophically, because the file is still locked by the very same daemon. Using the fork option, the Java
     * compilers loading the annotation processor exit after the compilation is done, thus freeing the file and
     * invalidating the lock after the build is done.
     *
     * TLDR; Fork or the build process will explode due to locked files!
     */
    tasks.withType(JavaCompile) {
        options.fork = true
    }

    plugins.withType(JavaPlugin) {
        jar {
            manifest {
                attributes(
                        'Implementation-Title': 'flint',
                        'Implementation-Version': fixedVersion,
                        'Implementation-Vendor': 'labymedia',
                        'Build-Timestamp': new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
                        'Build-Jdk': "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})",
                        'Build-OS': "${System.properties['os.name']} ${System.properties['os.arch']} ${System.properties['os.version']}",
                        'Sentry-dsn': "413b8f3fc06b407f9e8b1f5bd41258eb"
                )
            }
        }

        javadoc {
            options.addStringOption("tag", "apiNote:a:API Note:")
            options.addStringOption("tag", "implSpec:a:Implementation Requirements:")
            options.addStringOption("tag", "implNote:a:Implementation Note:")
        }

        publishing {
            publications {
                mavenJava(MavenPublication) {
                    from components.java
                    versionMapping {
                        usage('java-api') {
                            fromResolutionOf('runtimeClasspath')
                        }
                        usage('java-runtime') {
                            fromResolutionResult()
                        }
                    }
                }
            }
        }
    }
}
